<!--page master-->
<div id="main_wrap">
	<div id="main">
		<img src="<#=Magix.config().appHome+'theme/'#>images/<#=page<=1?'index':'content'#>.jpg" />
		<#=pageContent#>
	</div>
</div>

<!--page-->
<div class="title theme">
	末日前的黎明
</div>
<div class="content theme-content">
	<div class="item i1">习惯</div>
	<div class="item i2">知己知彼</div>
	<div class="item i3">解决方案</div>
	<div class="item i4">内在美</div>
	<div class="item i5">弹性</div>
	<div class="item i6">以人为本</div>
	<div class="item i7">信任</div>
	<div class="item i8">爱</div>
	<div class="item i9">问题</div>
	<div class="item i10">隐患</div>
</div>

<!--page-->
<div class="lecture">
	Magix核心升级总结<br />
	1.0来了，嘎嘎~~
	<div class="name">--行列</div>
</div>

<!--page-->
<div class="title">
	目录
</div>
<div class="content">
	<ol>
		<li>过去的问题</li>
		<li>我的目标</li>
		<li>重构结果</li>
		<li>升级指南</li>					
		<li>代码细节与风险</li>
	</ol>
</div>
<!--page-->
<div class="title">
	目录
</div>
<div class="content">
	<div class="main-sub">过去的问题</div>
</div>

<!--page-->
<div class="title">
	目录-过去的问题
</div>
<div class="content">
	<ol>
		<li>我们的MVC</li>
		<li>Router</li>
		<li>Event</li>
		<li>异步</li>
		<li>配置约定</li>
		<li>View渲染依赖</li>
		<li>Model与Collection</li>
		<li>其它</li>
	</ol>
</div>

<!--page-->
<div class="title">
	目录-过去的问题
</div>
<div class="content">
	<div class="main-sub">我们的MVC</div>
</div>

<!--page-->
<div class="title">
	目录-过去的问题-我们的MVC
</div>
<div class="content text">
	<br />
	magix算是MVC的一个实现，所以我们在底层会对接KISSY的MVC或backbone，然而我们的这个MVC又跟他们的有很大不同，我们抽象了VOM Vframe等，强化了View，弱化了Model Collection，甚至在收到的反馈中有提议说是把Model与Collection去掉。<br />
	<br />
	虽然我们对接了底层的MVC，但回头看一看，我们似乎没有用到底层MVC的什么方法或特点，不用也可以达到我们的目的
</div>

<!--page-->
<div class="title">
	目录-过去的问题-我们的MVC
</div>
<div class="content text">
	<br />
	既然我们不像MVC，我们一定要把自已弄的像MVC吗？虽然对接了底层MVC，但在实际运用中没得到什么好处，为何不考虑去掉？我们一定要使用底层的MVC，加长整个继承深度，增大学习成本吗？<br /><br />我们的目标是什么？做好viw的管理，但要灵活，不要硬套。<br /><br />
	借鉴别人的长处，走一条属于自已的路<br /><br />

</div>

<!--page-->
<div class="title">
	目录-过去的问题
</div>
<div class="content">
	<div class="main-sub">Router</div>
</div>

<!--page-->
<div class="title">
	目录-过去的问题-Router
</div>
<div class="content text">
	http://www.etao.com/#!/home/a=b&c=d;<br />
	我们的配置(app/config/ini)：<br />
	pathViewMap:{<br />
	　　"/home":"app/views/home",<br />
	　　"/404":"app/views/404"<br />
	}<br />
	<br />
	问题：<br />
	1. 地址栏中使用/home/a=b&c=d，配置中是/home，很难发觉最后一个/是分割pathname与参数的分割符<br />
	2. 考虑etao.com/home 与etao.com/home/ 这种传统url，这2种pathname是不一样的，前者是/home后者是/home/，所以按这种去理解hash中的pathname会带来困惑
</div>

<!--page-->
<div class="title">
	目录-过去的问题-Router
</div>
<div class="content text">
	404的配置：<br />
	return {<br />
	　　notFoundPath:"<span class="red bold">/</span>404",<br />
	　　pathViewMap:{<br />
	　　　　"/home":"app/views/home",<br />
	　　　　"<span class="red bold">/</span>404":"app/views/404"<br />
	　　}<br />
	}<br />
	<br />
	问题：<br />
	注意上面的红斜杠，其实这个红斜杠去掉也可以正常运行，这样就给理解并掌握pathname的配置带来不便
</div>

<!--page-->
<div class="title">
	目录-过去的问题-Router
</div>
<div class="content text">
	有时候我们需要多个pathname对应同一个view，我们这样写的配置文件：<br />
	pathViewMap:{<br />
	　　"404":"app/views/404",<br />
	　　"/flow":"app/views/layouts/default",<br />
	　　"/home":"app/views/layouts/default"<br />
	}<br />
	<br />
	/flow与 /home都使用 app/views/layouts/default ，当还有更多pathname时我们可能简写成下面这种形式(见下页)
</div>

<!--page-->
<div class="title">
	目录-过去的问题-Router
</div>
<div class="content text">
	引入defaultViewName来解决相同view的复用问题：<br />
	defaultViewName:"app/views/layouts/default",<br />
	pathViewMap:{<br />
	　　"404":"app/views/404",<br />
	　　"/flow":"",<br />
	　　"/home":""<br />
	}<br />
	<br />
	问题：<br />
	1. 使用空字符串来表示要使用defaultViewName，使理解变得复杂化<br />
	2. 这样无法解决另外一个，/pathA /pathB 用 viewX， /pathC /pageD 用viewY，所以当出现这种时，就需要自已权衡一下，要么为其中的一个建立defaultViewName，另外一个去写完整的配置，要么一个一个写完整
</div>

<!--page-->
<div class="title">
	目录-过去的问题-Router
</div>
<div class="content text">
	最终可能是：<br />
	return {<br />
	　　indexPath:"/flow",<br />
	　　notFoundPath:"404",<br />
	　　defaultViewName:"app/views/layouts/default",<br />
	　　pathViewMap:{<br />
	　　　　"404":"app/views/404",<br />
	　　　　"/flow":"",<br />
	　　　　"/home":"",<br />
	　　　　"/pathA":"app/views/viewX",<br />
	　　　　"/pathB":"app/views/viewX"<br />
	　　}<br />
	}<br />
	对于后续维护者将直接面对这样的配置，不了解整个过程的情况下很难下手去做新的调整
</div>

<!--page-->
<div class="title">
	目录-过去的问题-Router
</div>
<div class="content text">
	url中pathname与view对应是，采取pathname与view映射，在/上存在理解分歧，另外这个地方是pathname映射view，view是被动引用的<br /><br />
	在我们vframe中引用其它view是采用的是直接写view的路径，如&lt;vframe view_name="app/views/list"&gt;&lt;/vframe&gt;此处的view是主动引用的<br /><br />
	由上面提到的/和view的使用情况，会给开发者带来路径不统一，较凌乱的感觉<br />
	看一下开发人员的反馈：<br />
	init.js:  '/plan/list': '',<br />
	html:  &lt;a href="#!/plan/list/" hidefocus="true"&gt;计划&lt;/a&gt;<br />
	vframe: &lt;vframe id="vc-header" view_name="app/views/header"&gt;&lt;/vframe&gt;<br /><br />

	<span class="red">原来并未实现pushState，此处的问题略过</span>
</div>

<!--page-->
<a name="core_problems_router_mu"></a>
<div class="title">
	目录-过去的问题-Router
</div>
<div class="content text">
	程序中的问题：<br />
	location.hash='a';<br />
	location.hash='b';运行这2行代码<br />
	触发2次hashchange事件，但在这2次事件中通过location.hash拿到的值都是b<br /><br />
	我们要修改地址栏中的参数，是通过Router.navigateTo方法进行的，而在我们原来的view中，访问地址栏的参数通常是用queryModel拿到的，因为上述问题的存在，我们并不能通过Router.navigateTo('a=b');Router.naviateTo('c=d');调用2次方法放2个参数上去，最终只能把c=d放在地址栏上，所以queryModel也只能取到c的值，a的值是没有的，这种问题会让开发者调试很久，幸运的话知道了问题的所在，不幸运的话白白的浪费时间，开发效率大打折扣
</div>

<!--page-->
<div class="title">
	目录-过去的问题
</div>
<div class="content">
	<div class="main-sub">Event</div>
</div>

<!--page-->
<div class="title">
	目录-过去的问题-Event
</div>
<div class="content text">
	不支持所有的事件代理：<br />
	blur<br />
	focus<br />
	focusin<br />
	focusout<br />
	mouseenter<br />
	mouseleave<br />
	mousewheel<br />
	valuechange<br />
	当遇到上述事件时，您需要自已去绑定，不能使用view提供的代理，所以这一点需要使用magix的开发者心里清楚，不能顺手就写个 mxfocus 出来，当有些事件可以方便的写标签，view中写处理就可以了，有些需要自已动态绑定(此时开发者要在view刷新，销毁时，记得去解绑事件)，这就不太爽了
</div>

<!--page-->
<div class="title">
	目录-过去的问题-Event
</div>
<div class="content text">
	事件处理：<br />
	events:{<br />
	　　click:{<br />
	　　　　saveUserInfo:function(view,target,params){<br />

	　　　　}<br />
	　　}<br />
	}<br />
	<br />
	问题：<br />
	1. 其实参数target准确来讲是currentTarget，并不是真正触发事件的那个节点<br />
	2. 有时我们需要target和currentTarget时，需要magix/view进行一次升级，那么参数依次往里加，变成这样么？function(view,target,params,realTarget) ，如果后续还有需求，还是向后加么？
</div>

<!--page-->
<a name="core_problems_event_danger"></a>
<div class="title">
	目录-过去的问题-Event
</div>
<div class="content text">
	还有一处隐患：<br />
	&lt;vframe id="magix_main"&gt;<br />
	　　&lt;button mxclick="change"&gt; change &lt;/button&gt;<br />
	　　&lt;vframe id="magix_vf1"&gt;<br />
	　　　　&lt;button mxclick="change"&gt; change &lt;/button&gt;<br />
	　　&lt;/vframe&gt;<br />
	&lt;/vframe&gt;<br />
	<br />
	问题：<br />
	1. 嵌套vframe有相同的事件change要处理，子view vf1在mxclick并没有进行_stop_取消冒泡，那么vf1中在处理完事件后，事件冒泡到main中，导致main中的事件也会触发（这个问题排查起来也很麻烦）<br />
	2. 如果你取消冒泡，问题是解决了，但在引入第三方组件时，一些组件监听document做自已的动作时，就会有问题
</div>

<!--page-->
<div class="title">
	目录-过去的问题-Event
</div>
<div class="content text">
	反馈一个跟magix无关的：<br />
	&lt;div class="dropdown-container"&gt;<br />
	　　&lt;ul&gt;<br />
	　　　　&lt;li&gt;item1&lt;/li&gt;<br />
	　　　　&lt;li&gt;item2&lt;/li&gt;<br />
	　　&lt;/ul&gt;<br />
	&lt;/div&gt;<br />
	假设上面的一个菜单，假设Brix实现的，为了达到点击其它地方关闭菜单，在document上注册mouseodwn或click，当用户点击时，target不在div内部，则表示可以关闭这个菜单，点击在div内部不关闭，功能实现后嘛问题也没有<br />
	现在假设点击item1时，把item1从列表中删除，点击监听的事件，可能在li 也可能在ul 也可能在div上，删除后并没有停止事件冒泡，那么当事件冒泡到document上时，Brix组件拿到target后，判断target是否在div内，因现在的li已经从文档中移除，那么通过判断肯定认为target不在div内，导致菜单关闭，在保持冒泡的情况下，达到这个效果，需要先判断target是否还在文档内
</div>

<!--page-->
<a name="core_problems_async"></a>
<div class="title">
	目录-过去的问题
</div>
<div class="content">
	<div class="main-sub">异步</div>
</div>

<!--page-->
<div class="title">
	目录-过去的问题-异步
</div>
<div class="content text">
	<ul>
		<li>AJAX获取数据(model和其它第三方组件或类库)</li>
		<li>异步加载js文件(按需加载组件)</li>
		<li>view的加载是异步的</li>
		<li>修改hash与hashchange事件的派发</li>
		<li>原来view中initial方法曾使用setTimeout进行特殊处理</li>
	</ul>
	<br />
	稍后我一一道来这里面的问题，及原来的方案真的能解决这些问题么？没有其它隐患么？（上个厕所先）
</div>

<!--page-->
<div class="title">
	目录-过去的问题-异步
</div>
<div class="content text">
	ajax获取数据与异步加载js文件差不多，一并讲解：<br />
	考虑下面的代码：<br />
	render:function(){<br />
	　　//...<br />
	　　model.load({<br />
		　　success:function(){<br />
	　　　　　　S.one('#'+self.id).html();<br />
	　　　　}<br />
	　　})<br />
	}<br />
	<br />
	问题：
	数据获取是异步的，当success方法被调用时，此时view很有可能已经销毁，比如用户已经点击其它链接跳到下一个模块上了，那么当这个success方法被调用，里面访问DOM节点，找不到，报错(原来的解决方案见下页)
</div>

<!--page-->
<div class="title">
	目录-过去的问题-异步
</div>
<div class="content text">
	解决方案：<br />
	render:function(){<br />
	　　//...<br />
	　　model.load({<br />
		　　success:function(){<br />
	　　　　　　<span class="red">if(self.exist){</span><br />
	　　　　　　　　S.one('#'+self.id).html();<br />
	　　　　　　<span class="red">}</span><br />
	　　　　}<br />
	　　})<br />
	}<br />
	在我们view初始化时会把exist置为true,销毁时置为false<br />
	问题：<br />
	这样能解决view销毁后success回调访问DOM出错问题，但下页的这个问题如何解决？
</div>

<!--page-->
<div class="title">
	目录-过去的问题-异步
</div>
<div class="content text">
	真实应用场景如下：<br />
	有A,B两个Tab，A到B切换时会引起Tab内容TabPanel这个view的刷新，而内容是通过异步获取的，假设取A对应的内容需要花费3秒钟，取B的内容需要花费500毫秒。用户点击A Tab停留1秒钟后，又点击B Tab，500毫秒后B的内容返回，Tab内容显示为B的内容，问：1.5秒后，Tab内容还显示着B的内容吗？<br />
	<br />
	解：问题的关键是TabPanel这个view在A B切换时，它干了些什么？因为仅是tab的切换，所以它本身是通过queryModelChange接口，接收到有变化时，重新渲染(刷新)了自已，view这个对象并没有销毁(此时也不需要销毁，销毁发生在整个vframe标签被重新输出，或pathname对应的根view有变化)，因此exist始终为true，变化的仅是调用了2次render方法，产生了2个异步请求，而这2个请求后发出的先返回，导致页面会先显示B的内容，稍后A的返回后，判断条件成立(if(self.exist)通过)，最终显示A的内容
</div>

<!--page-->
<div class="title">
	目录-过去的问题-异步
</div>
<div class="content text">
	这个问题如何解决？<br />
	难！<br />
	<br />
	在我们的magix支撑的项目中，每个项目或多或少的都有这个问题，抛开magix，包括传统的ajax取内容，比如新闻列表的翻页，在用户点击较快的情况下，因为异步并不能保证先发出的请求先返回，所以很有可能页码选中第3页，但显示却是第2页的内容<br />
	<br />
	当出现这种问题时，我们只能在回调中进行一次环境判断，识别出返回的数据是否对应着当前的环境，如果对应就进行后续的操作，否则就扔掉这个数据，幸运的是，在这次重构中解决掉了这个问题^_^
</div>

<!--page-->
<div class="title">
	目录-过去的问题-异步
</div>
<div class="content text">
	view的加载<br />
	<br />
	这是magix内部的问题，但该问题会引起这个问题，原来并没有考虑到：<br /><br />
	view这个js加载的时间很长，在这个过程中，又mountView，问题跟前面提到的多次异步获取数据是一样的，同样会有后加载的先回来，先加载的后回来的风险在里面，只是在我们开发，上线，加载js文件都很快，所以这个问题并没有暴露出来，所以捏，有些问题就这样糊弄过去了
</div>

<!--page-->
<div class="title">
	目录-过去的问题-异步
</div>
<div class="content text">
	修改hash与hashchange事件的派发<br />
	<br />
	Router一节中有更多的说明，请参考：<a href="linkTo:core_code_router">Router</a>
	<br />
	<br />
	又很幸运的是在这次重构中这个问题也解决了，其实原来也有相关的解决方案，但是因为别的地方干扰，导致在一些地方频繁切换链接时，会导致页面死掉，这块龙笛遭遇过。我相信重构后这个异步问题及死掉已成为历史
</div>

<!--page-->
<div class="title">
	目录-过去的问题-异步
</div>
<div class="content text">
	setTimeout<br />
	<br />
	这个在原来magix代码中2处用到，均是view initial方法中用到的，其中第2个是为了等待第1个的完成，因此我们重点讨论第1个setTimeout<br /
	<br /><br />
	原来为什么引入setTimeout？<br />
	为了支持自动渲染子view，所以在调用setViewHTML方法设置完view的html后，会触发一个rendered事件，view所对应的vframe接收到这个事件后，从当前view中找出vframe标签，继续渲染子view<br />
	<br />
	假设原来没有setTimeout时，view的构造渲染顺序是这样的:<br />
	见下页
</div>

<!--page-->
<div class="title">
	目录-过去的问题-异步
</div>
<div class="content text">
	无setTimeout<br />
	<br />
	new -> base ctor -> view ctor -> initial -> getTmpl -> init -> render -> setViewHTML -> 派发rendered事件(<span class="red">当然这里面需要区分view有模板，无模板，开发，发布等各种情况，在调用render方法后，render方法内是同步调用setViewHTML还是异步调用setViewHTML，情形较复杂，此处以常见举例</span>)<br />
	<br />
	在vfame中是这样绑定对应view的rendered事件：<br />
	var v=new View(..);<br />
	v.bind('rendered',fn);<br />
	new完后才绑定的rendered事件，我们在init中可能会这样做：this.bind('rendered',fn);我们会发现开发者绑定的rendered事件会早于我们vframe中的绑定，当开发人员在他的rendered回调中进行访问其它外部资源时(同级vframe)，就会有问题，所以引入了setTimeout
</div>

<!--page-->
<div class="title">
	目录-过去的问题-异步
</div>
<div class="content text">
	setTimeout引入后带来的问题<br />
	<br />
	这个问题似乎比前面的ajax请求还要严重些，就是引入后整个vom vframe view渲染的流程变得异常复杂，magix开发者很难确定并识别setTimeout对应的方法什么时间点被调用，给维护带来很大的困难，虽然到线上后并没有因它出过什么问题，但是有它的存在还是像个炸弹一样，不知道什么时间就bomb了
</div>

<!--page-->
<div class="title">
	目录-过去的问题
</div>
<div class="content">
	<div class="main-sub">配置约定</div>
</div>

<!--page-->
<div class="title">
	目录-过去的问题-配置约定
</div>
<div class="content text">
	<br />关于app/config/ini,这个在讨论Router时已经讨论过相关的配置了，其实这个配置文件里除了pathname映射配置外，并没有其它的配置，但是开发者需要牢记搭建环境时，需要去配置这个文件，容易让新手觉得繁琐，产生抵触情绪(硬性的东西太多)<br /><br />
	属性的不规范，比如我们引用view时，view_name="app/views/list"，我们在约定根节点id时，vf-root，咋感觉跟大多数的习惯不一致呢？<br /><br />
	mxclick="handler:params:_stop_";mxclick="handler:params:_preventDefault_";mxclick="handler:params:_halt_"; 对比后，似乎_preventDefault_长了些
</div>

<!--page-->
<div class="title">
	目录-过去的问题-配置约定
</div>
<div class="content text">
	<br />
	vframe加载相应的view时：<br />
	&lt;vframe <span class="red bold">view_name</span>="app/views/list"&gt;&lt;/vframe&gt;
	<br /><br />
	默认的根view id：<br />
	<span class="red bold">vf-root</span><br /><br />
	在我印象中属性 class名称连接符一般用 “-”，id一般用“_",当然这个问题只是习惯上的不同而已
</div>


<!--page-->
<div class="title">
	目录-过去的问题
</div>
<div class="content">
	<div class="main-sub">View渲染依赖</div>
</div>

<!--page-->
<div class="title">
	目录-过去的问题-View渲染依赖
</div>
<div class="content text">
	参考insight项目，侧边栏的渲染需要等待其它view就绪<br /><br />
	上次《magix总结》中，提出的数据渲染依赖<br /><br />
	具体描述为：<br >
	1. A B 2个View的渲染依赖同一份数据，这份数据有可能在前端，也有可能在后台，A B如何共享同一份数据？当是后台数据时，难道A B各发起一个请求到后台取这同一份数据？如何只发起一个请求？(项目中最常见)<br />
	2. B view的渲染依赖A view的渲染完成，参考insight项目，B view如何知道A已渲染完成？<br />
	3. 后台取数据请求是异步的，如何保证安全(依赖安全，并非安全的取数据)？
</div>

<!--page-->
<div class="title">
	目录-过去的问题-View渲染依赖
</div>
<div class="content text">
	postMessageTo , receiveMessage<br /><br />
	这是以前的解决方案<br /><br />
	问题：<br >
	1. 当2个view之间可任意通信时，是否破坏了相互独立原则？<br />
	2. 任意的通信会给后期的维护带来一定的麻烦<br />
	3. 当发送消息时，可能目标view异步加载尚未成功（<a href="linkTo:core_problems_async">参考异步这一块的问题</a>），如何保证消息投递到？<br />
</div>

<!--page-->
<div class="title">
	目录-过去的问题
</div>
<div class="content">
	<div class="main-sub">Model与Collection</div>
</div>

<!--page-->
<div class="title">
	目录-过去的问题-Model与Collection
</div>
<div class="content text">
	<br /><br />
	<br /><br />
	<br >
	<div style="text-align:center;">(在magix扩展中总结，敬请期待)</div>
</div>

<!--page-->
<div class="title">
	目录-过去的问题
</div>
<div class="content">
	<div class="main-sub">其它</div>
</div>


<!--page-->
<div class="title">
	目录-过去的问题-其它
</div>
<div class="content text">
	考虑这样的代码：<br />
	S.io({<br />
	　　url:'...',<br />
	　　data:'...',<br />
	　　success:function(){<br />
	　　　　<br />
	　　},<br />
	　　error:function(){<br />
	　　　　<br />
	　　}<br />
	})<br />
	很常见的ajax请求书写方法，有问题吗？
</div>

<!--page-->
<div class="title">
	目录-过去的问题-其它
</div>
<div class="content text">
	放在我们的view中：<br />
	render:function(){<br />
	　　S.io({<br />
	　　　　url:'...',<br />
	　　　　data:'...',<br />
	　　　　success:function(){<br />
	　　　　　　<br />
	　　　　},<br />
	　　　　error:function(){<br />
	　　　　　　<br />
	　　　　}<br />
	　　})<br />
	}<br />
	有问题吗？
</div>

<!--page-->
<div class="title">
	目录-过去的问题-其它
</div>
<div class="content text">
	render:function(){<br />
	　　S.io({<br />
	　　　　url:'...',<br />
	　　　　data:'...',<br />
	　　　　success:function(){<br />
	　　　　　　<span class="red">if(_self.exist){</span><br />
	　　　　　　　　...<br />
	　　　　　　<span class="red">}</span><br />
	　　　　},<br />
	　　　　error:function(){<br />
	　　　　　　<br />
	　　　　}<br />
	　　})<br />
	}<br />
	有问题吗？
</div>

<!--page-->
<div class="title">
	目录-过去的问题-其它
</div>
<div class="content text">
	<br />
	开发人员的编程习惯需要照顾，虽然一些问题magix中给出了解决方案，但要针对经常出现的问题给予良好的解决，要不然会让开发人员感觉很不爽，这一块会在后面的代码细节与风险中给出示例和解决方案，<a href="linkTo:core_code_habit">点击这里直达</a>
</div>

<!--page-->
<div class="title">
	目录
</div>
<div class="content">
	<div class="main-sub">我的目标</div>
</div>


<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content" style="top:12%">
	<ol>
		<li>话说原来</li>
		<li>View的渐进增强</li>
		<li>View异常的处理</li>
		<li>接口管理与数据缓存</li>
		<li>View转场动画</li>
		<li>View关注与自已有关的参数</li>
		<li>View之间的消息传递</li>
		<li>API命名调整</li>
		<li>异步请求过期</li>
		<li>模块自由组装</li>
	</ol>
</div>

<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content">
	<div class="main-sub">话说原来</div>
</div>

<!--page-->
<div class="title">
	目录-我的目标-话说原来
</div>
<div class="content text">
	<br />
	为了应对复杂的应用场景，你不能强迫所有用户一定要用jQuery、seajs、KISSY等，但在我们实际的项目中，或多或少的都会用到一些底层类库，magix为了解决底层类库不统一的问题，采用了模板方法的方式进行代码设计，可方便的切换底层类库(需要有按需加载的功能)，这一块我们已经实现并且明显没有问题(哈哈，笑，我想到了别的)<br ><br />
	所以我们要针对不同的开发者，不同的用户，有相仿的解决方案，减少学习成本，方便使用者迁移。magix代码中不依赖类库实现的在模板中，依赖类库的地方采取一定的方案对接<br />
	接下来的一些地方也都是针对这些来进行提出的
</div>

<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content">
	<div class="main-sub">View的渐进增强</div>
</div>

<!--page-->
<div class="title">
	目录-我的目标-View的渐进增强
</div>
<div class="content text">
	<br />
	magix主要做的是view的管理(区块的管理)，正如前面所说，我们的应用场景很复杂，要在复杂中保持简单，我们针对不同的场景提供相仿但不相同的解决方案。<br /><br />
	比如在PC端，我们可以用很炫的动画，很大的区块，很方便的事件代理来处理我们的应用，但在手机上呢？为了节省资源，也许我们要关闭动画，划出更小的区块等措施来进行效率优化<br /><br />
	仅关闭一些功能就可以了么？代码如何做到需要的加载，不需要的不加载？难道在手机端你也要加载PC上所有的代码然后进行一些功能的关闭么？
</div>

<!--page-->
<div class="title">
	目录-我的目标-View的渐进增强
</div>
<div class="content text">
	<br />
	所以针对上述问题，希望magix/view能够提供基础的生命周期，在此基础上，view分发为PC端 mobile端等各自的view，可以在各自的view添加自已所需要的功能，但是它们的生命周期和一些基础事件的派发是一样的，即使开发mobile的人员改到PC端来开发，也会很容易上手<br /><br />
	同样在分发PC 和 mobile view时，也同样会有一些代码是公用的，另外一些代码是基于底层类库的，我们规定好接口名称，这样虽然底层类库不同，但我们对外是一致的，所以一刀切开公用和依赖底层类库实现的代码，同时以回字形逐渐的增强，增大view。增大的同时也遵循一刀切的原则
</div>

<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content">
	<div class="main-sub">View异常的处理</div>
</div>

<!--page-->
<div class="title">
	目录-我的目标-View异常的处理
</div>
<div class="content text">
	<br />
	在view中我们会定义一些方法供开发人员实现，但开发人员在实现时，我们无法保证开发人员的代码一定是正确执行的，当异常出现时，很有可能导致我们的内部代码无法正常执行下去，比如：<br />
	for(var i=0;i&lt;subVframes.length;i++){<br />
	　　subVframes[i].mountView()<br />
	}<br />
	假设subVframes.length=3;当第1个渲染出错时，会导致后续2个也无法正常渲染<br />
	这个问题跟曾经的jQuery.ready问题是一样的，jQ.ready在执行时，并没有进行try cache，导致多个依赖ready执行的方法，如果第一个出错，后续的无法正常执行<br />
	<span class="red">所以我们想做view的沙箱，其中的一个view出错不会影响到其它的view无法展示</span>
</div>

<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content">
	<div class="main-sub" style="font-size:200%">接口管理与数据缓存</div>
</div>

<!--page-->
<div class="title">
	目录-我的目标-接口管理与数据缓存
</div>
<div class="content text">
	<br />
	以往我们开发中，免不了使用后台数据，通常我们会在需要的地方直接ajax取，这样一些后台的URL可能就散落在各个Model和Collection中，有的写死在view中，不易查找，维护<br /><br />
	希望magix能集中管理请求的后台url，这样当我们需要查找或修改某个接口地址时非常方便，要不然就要到各个view的js文件中去慢慢找。
</div>

<!--page-->
<div class="title">
	目录-我的目标-接口管理与数据缓存
</div>
<div class="content text">
	<br />
	很多时候多个view依赖同一份数据，假设这份数据来自服务器，那么如何做到只发一个请求到后台？理想的编程当然是各个view发起各自的请求，这样可以保持view的独立性，减少来自别个view的影响，当把这个view拿到别处用的时候，依然可以正常使用，不需要额外的修改<br /><br />
	假设A B C 3个view需要同一份数据X，当A B C在一起的时候，只有一个请求到后台，当A B C分开的时候，是各自的请求到后台，有可能是3个请求，也就是独立的时候没问题，任意组装在一起的时候，只有一个请求，即保证了相互独立，又保证了不多发额外的请求<br /><br />
	<span class="red">该处的方案在magix扩展总结中展示</span>
</div>

<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content">
	<div class="main-sub">View转场动画</div>
</div>

<!--page-->
<div class="title">
	目录-我的目标-View转场动画
</div>
<div class="content text">
	<br />
	该部分是考虑去做的部分，我记得木头曾让我看过一个切换动画，觉得如果maigx的view在切换时，能够有一定的动画效果，或许会增色不少，但需要考虑效率和内存的问题，而且当时我也说了我们的view在切换时，直接通过innerHTML替换的，如何保留着上一个view的内容做动画切换是个问题，所以这个转场动画提了一下就过去了
</div>

<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content">
	<div class="main-sub" style="font-size:180%">View关注与自已有关的参数</div>
</div>

<!--page-->
<div class="title">
	目录-我的目标-View关注与自已有关的参数
</div>
<div class="content text">
	<br />
	看原来的view刷新：<br />
	queryModelChange:function(){<br />
	　　this.render();<br />
	　　//VOM.getElementById(this.vcid).mountView('');<br />
	}<br />
	地址栏参数改变，会向各个view发送queryModelChange的消息，有时候开发人员就像上面这样，收到消息就把整个view个刷新了，其实有些地址栏的参数改变是不需要刷新的<br />
	举例：http://www.etao.com/home#!/list/tab=1&page=2;<br />
	页面上有tabs和list这2个view，当list的参数page发生改变时，tabs这个view是不需要刷新的(tab改变tabs才需要刷新)，按照上面的代码，tabs也会刷新
</div>

<!--page-->
<div class="title">
	目录-我的目标-View关注与自已有关的参数
</div>
<div class="content text">
	<br />
	改进的方案可能是这样：<br />
	queryModelChange:function(qm){<br />
	　　<span class="red">if(qm.isChanged('tab')){</span><br />
	　　　　this.render();<br />
	　　　　//VOM.getElementById(this.vcid).mountView('');<br />
	　　<span class="red">}</span><br />
	}<br />
	当这个view对应的参数较多时，该处的判断可想而知<br />
	引起问题的根源在于query改变时，我们会向每个view传递queryModelChange，并不关心当前view与哪些参数有关，如果能够做到与这个view有关的参数发生改变时，才传递queryModelChange这个消息，会给我们的开发人员带来不少便利，同时也不会减少一些view的不必要的刷新
</div>

<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content">
	<div class="main-sub" style="font-size:180%">View之间的消息传递</div>
</div>

<!--page-->
<div class="title">
	目录-我的目标-View之间的消息传递
</div>
<div class="content text" style="font-size:140%">
	来自开发人员的反馈：<br />
	父 View → 子 View：父 View 绑定子 View 时把参数传入，子 View JS 加载后通过闭包机制访问参数。<br />
子 View → 父 View：父 View 绑定子 View 时传入的参数可以含有特殊属性 message，属性值是一个函数，子 View 创建时把函数绑定到自定义事件 message；统一称为函数 message。因为函数 message 是在父 View 中定义的，可以通过闭包机制引用父 View 和其他环境变量。<br />
无论是父 → 子、子 → 父，都需要手动调用 View.trigger('message ' ) 即以自定义事件的方式触发；或者直接调用 self.options.message() 也可以，即以回调函数的方式触发。
自定义事件 message 结合自定义数据 messageData 非常灵活，在 jQuery 中也有类似的思想；message 机制似乎是自定义事件和回调函数思想的结合体，即能够以自定义事件的方式使用，也能够以回调函数的方式使用。
可以总结为：把回调函数以自定义事件的方式触发并执行。绑定子 view 时，传入属性 message，属性值是函数，然后由子 View 负责在何时的时机触发，把回调函数在概念上升级为自定义事件。
对回调函数和自定义事件的理解和应用炉火纯青，但也有把简单的事情复杂化的嫌疑
</div>

<!--page-->
<div class="title">
	目录-我的目标-View之间的消息传递
</div>
<div class="content text">
	前面提到的消息传递仅限于父子之间的关系，在 过去的问题中，我也提到渲染依赖时，有时候view之间并不是父子关系，也是需要传递消息的，所以当时设计出了postMessageTo与receiveMessage，但这块依赖有同学提出，这样做会感觉太自由，任意2个都可以传递消息，有点不好把控<br /><br />
	就view之间的消息传递这块，仍需改进
</div>

<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content">
	<div class="main-sub">API命名调整</div>
</div>

<!--page-->
<div class="title">
	目录-我的目标-API命名调整
</div>
<div class="content text">
	<br />
	这个也是要整的，随着功能的推进，很多方法名已不能准确的表达它的意思，新手上手的时候，没必要了解整个magix的发展过程，所以在合适的时候调整一下API命名，会对我们的新手有很大的帮助，避免看到方法名却不知道它还有另外一个功能<br />
	<br />
	这也是我的一个目标
</div>

<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content">
	<div class="main-sub">异步请求过期</div>
</div>

<!--page-->
<div class="title">
	目录-我的目标-异步请求过期
</div>
<div class="content text">
	<br />
	这块在<a href="linkTo:core_problems_async">过去的问题中异步</a>有讲解，该处不做过多的描述<br />
	在现有的项目中，先请求后到来还是很常见的，那么对于类似的请求，比如翻页，当我点击第1页，数据还没有回来时，我又点击了第2页，那么客户端应该只处理第2页返回的数据才对，即使第1页的数据返回，也已经没必要处理了，给异步请求一个过期点，当点击第2页时，虽然第1页的请求还没有返回，其实我们可认定它是一个过期的请求了，返回也不用处理<br />
	<br />
	这块也是我想做到的，因为目前项目中这种隐患随处可见，如果能在view中消除这个隐患，将会提升整个应用的健壮
</div>

<!--page-->
<div class="title">
	目录-我的目标
</div>
<div class="content">
	<div class="main-sub">模块自由组装</div>
</div>

<!--page-->
<div class="title">
	目录-我的目标-模块自由组装
</div>
<div class="content text">
	<br />
	原来为了简单，magix所有的文件打包在一起，直接拷走一个js文件即可使用，有时候整个项目下来，magix当中一些模块并没有用到，造成了冗余，缺少量身定制的功能<br /><br />
	有时候想把一些模块替换成自已的，也没办法做到。随着项目的越来越多，要求各不一样，能够达到模块化自由组装，magix就不会很被动的一直向里面添加新功能，新方法而变得臃肿<br /><br />
	这是我想达到的
</div>



<!--page-->
<div class="title">
	目录
</div>
<div class="content">
	<div class="main-sub">重构结果</div>
</div>

<!--page-->
<div class="title">
	目录-重构结果
</div>
<div class="content">
	<ol>
		<li>拆分magix</li>
		<li>Router</li>
		<li>Event</li>
		<li>异步</li>
		<li>配置约定</li>
		<li>动画</li>
		<li>Model与Collection(在扩展中总结)</li>
	</ol>
</div>

<!--page-->
<div class="title">
	目录-重构结果
</div>
<div class="content">
	<div class="main-sub">拆分magix</div>
</div>

<!--page-->
<div class="title">
	目录-重构结果-拆分magix
</div>
<div class="content text">
	原来的magix包含的模块有：<br />
	magix<br />
	model<br />
	router<br />
	vom<br />
	vframe<br />
	view<br />
	mu<br />
	mustach<br />
	tmpl<br />
	...<br />
	比较多，这也是目标中想做模块自由组装的目的
</div>

<!--page-->
<div class="title">
	目录-重构结果-拆分magix
</div>
<div class="content text">
	抛开这么多的模块不谈，回归到magix的最初的目标上，magix到底是为了什么而存在？主要做什么？<br />
	可以简单理解它是MVC，但又不像，因为magix是增强对view的管理，抽象出vframe等进行父子关系管理。在我们实际运用中，由于数据的多样性，很难全部用model进行数据的管理，因此我们弱化了model，强化了view<br />
	项目、应用虽然很多，但它们之间在对界面的管理是相似的，而我们magix又是主推view管理的，既然这样，回归到magix的简单，把magix一拆为二，分为magix核心部分与扩展部分<br />
	magix核心部分：router提供对url的解析与修改，vom vframe view(仅核心)构成整个页面的管理<br />
	magix扩展部分：model collection 动画 模板等提供app中常用的工具<br />
	<br />
	magix核心更侧重基础生命周期管理，事件派发等，提供严谨的流程控制，对核心维护人员友好。magix扩展更侧重在magix核心的基础上向app开发人员提供常用工具，对开发人员友好
</div>

<!--page-->
<a name="core_result_rvr"></a>
<div class="title">
	目录-重构结果-拆分magix
</div>
<div class="content text">
	核心部分：
	<img src="images/magix_new.jpg" />
</div>

<!--page-->
<div class="title">
	目录-重构结果-拆分magix
</div>
<div class="content text">
	<br />
	保持各个模块的相互独立(高内聚，低耦合)，可任意拿出一个模块使用(理想状态)，所以Router与VOM之间是通过事件派发进行数据交换的<br /><br />
	VOM Vframe View之间的关系比较紧，但在程序中也是尽量保持互相独立，事实上它们之间的关系也是相互依赖的。为了程序清晰明了，采用了单向明确引用，比如VOM明确引用Vframe，而在Vframe中要使用VOM时，采用隐式访问的方式，让新手一眼看上去关系是清晰的，要不然如果Vframe也明确引用VOM，在解决循环依赖上麻烦，也会给阅读源码的人造成较大的不爽<br /><br />
	<span class="red">去除了底层MVC的对接，保持自已的清爽</span>
</div>

<!--page-->
<div class="title">
	目录-重构结果-拆分magix
</div>
<div class="content text">
	扩展部分：
	<img src="images/magix_mxapp.jpg" style="width:710px" />
</div>

<!--page-->
<div class="title">
	目录-重构结果-拆分magix
</div>
<div class="content text">
	<br />
	扩展这块较简单，除了view继承magix/view外，其它都是工具库的罗列，简单的堆砌哦~~
</div>

<!--page-->
<div class="title">
	目录-重构结果-拆分magix
</div>
<div class="content text">
	拆分后我们可以根据各自的侧重点进行单独的维护，毕竟一个人的精力是有限的<br /><br />
	回到我们前面的问题，目前我们尚未有根据需要把magix模块打包成一个文件的功能，现在是把核心打包成一个文件，扩展打包成一个文件，核心与扩展再打包成一个文件，简单的实现模块划分，让不同的项目各取所需。(adhoc项目使用核心与扩展，srp项目仅核心即可)<br /><br />
	同时以后如果划分pc与mobile时，只需要在扩展这块，扩展出pc常用的工具与view，mobile常用的工具与view即可，它们都是基于magix这个核心，所以可以提供一致的生命周期和编程体验。同时可以针对pc与mobile发挥各个的特点与优势(解决按需与view的渐进增强)
</div>

<!--page-->
<div class="title">
	目录-重构结果
</div>
<div class="content">
	<div class="main-sub">Router</div>
</div>

<!--page-->
<div class="title">
	目录-重构结果-Router
</div>
<div class="content text">
	<br />
	首先加入了history pushState的支持^_^<br /><br />
	统一了传统url与hash中的pathname与params，如http://www.etao.com/#!/home/a=b;现在是http://www.etao.com/#!/home?a=b<br /><br />
	对于要使用pushState时，需要后台的支持<br /><br />
	支持二者之间平滑切换，无须开发人员特意控制，比如在不支持history state的浏览器上，会自动平滑切换到hash上，向开发人员提供的API中，也已自动转换，不需要开发人员操心
</div>

<!--page-->
<div class="title">
	目录-重构结果
</div>
<div class="content">
	<div class="main-sub">Event</div>
</div>

<!--page-->
<div class="title">
	目录-重构结果-Event
</div>
<div class="content text">
	<br />
	全面的事件支持！再也不用烦心不冒泡的事件了<br /><br />
	调整的事件回调参数传递<br /><br />
	对于冒泡的事件magix自已处理，对于不冒泡的事件才对接底层类库，由类库实现<br /><br />
	同时在mxext/view中增加了queryEvents对象(<a href="http://magixjs.github.com/doc/symbols/MxView.html#queryEvents" target="_blank">查看API文档</a>)，可方便的把事件直接绑定在某些节点上，解决您对事件性能的担忧
</div>

<!--page-->
<div class="title">
	目录-重构结果-Event
</div>
<div class="content text">
	<br />
	解决：<br />
	&lt;vframe id="magix_main"&gt;<br />
	　　&lt;button mxclick="change"&gt; change &lt;/button&gt;<br />
	　　&lt;vframe id="magix_vf1"&gt;<br />
	　　　　&lt;button mxclick="change"&gt; change &lt;/button&gt;<br />
	　　&lt;/vframe&gt;<br />
	&lt;/vframe&gt;<br />
	<br />
	这样的隐患(<a href="linkTo:core_problems_event_danger">查看隐患详情</a>)，同时引入了data-handler进行指定哪个父vframe处理，即解决掉隐患，又能在您需要这个特性时，进行明确指定，阅读或维护您的代码都会变得清晰（<a href="linkTo:core_upgrade_event_mu">升级指南细节</a>）
</div>

<!--page-->
<div class="title">
	目录-重构结果
</div>
<div class="content">
	<div class="main-sub">异步</div>
</div>

<!--page-->
<div class="title">
	目录-重构结果-异步
</div>
<div class="content text">
	<br />
	不管怎样的异步，都会有问题，前面我们也说过很多。为了解决定个问题，首次在view中引入资源托管的概念(<a href="http://magixjs.github.com/doc/symbols/View.html#manage" target="_blank">API manage</a>)。view的生命周期多少有点复杂，但做为app开发者，无需了解view的生命周期(这是我们的目标)，那么当他引入第三方组件或发起异步请求时，都应当把这些资源托管给当前的view，这样当view刷新或销毁时，能自动帮你释放或销毁这些资源，您无须关心view该什么时间销毁，您要做的仅仅是把这些资源托管即可，对，就这么简单！(<a href="linkTo:core_code_manage">托管的细节</a>)	
</div>

<!--page-->
<div class="title">
	目录-重构结果-异步
</div>
<div class="content text">
	<br />
	向setTimeout 说不！！(前面setTimeout的问题)<br /><br />
	在这次重构中，对整个流程进行了详细的梳理，每一个环节都精确把控，避免setTimeout后整个过程扑朔迷离。同时解决了前面所说的，有些地方看似不用setTimeout解决不了的问题^_%，为了这个问题也得走一杯
</div>

<!--page-->
<div class="title">
	目录-重构结果
</div>
<div class="content">
	<div class="main-sub">配置约定</div>
</div>

<!--page-->
<div class="title">
	目录-重构结果-配置约定
</div>
<div class="content text">
	<br />
	首先去掉了app/config/ini的硬性配置<br /><br />
	<span class="red">所有的映射都是view路径在前，映射在后。不管在哪view都是主动的，统一与view相关的配置</span><br /><br />
	弹性配置，我先告诉你一个1，你就能把你的app跑起来，各种异常都已帮你处理，不会因为一些东西没有配置，在某些时候出错。当你需要进行特殊定制时，比如404，那我再告诉你一个2，你就能实现404定制，你还需要其它时，我再告诉你3，一层层的引导、弹性配置，不至于上来就要配置一大堆参数吓跑初学者<br /><br />
	更规范的，更接近大众的命名与属性约定，咱不搞另类
</div>

<!--page-->
<div class="title">
	目录-重构结果-配置约定
</div>
<div class="content text">
	<br />
	原来pathname与view的映射：<br />
	pathViewMap:{<br />
	　　"404":"app/views/404",<br />
	　　"/flow":"app/views/layouts/default",<br />
	　　"/home":"app/views/layouts/default"<br />
	}<br />
	现在的：<br />
	pathCfg:{<br />
	　　notFound:"app/views/404",<br />
	　　map:{<br />
	　　　　"app/views/layouts/default":["/flow","/home"]<br />
	　　}<br />
	}<br />
</div>

<!--page-->
<div class="title">
	目录-重构结果
</div>
<div class="content">
	<div class="main-sub">动画</div>
</div>

<!--page-->
<div class="title">
	目录-重构结果-动画
</div>
<div class="content text">
	<br />
	正如你现在看到的这个PPT一样，magix正式加入转场动画^_&;<br /><br />
	关于动画这块的设计与风险详见:<a href="linkTo:core_code_anim">代码细节与风险，动画</a><br /><br />
	虽然有动画的支持，但内存的占用及因动画带来的其它问题有待进一步的处理，不管怎样，动画切换已经不用再羡慕别人的了，咱自已也有了~~
</div>


<!--page-->
<div class="title">
	目录
</div>
<div class="content">
	<div class="main-sub">升级指南</div>
</div>

<!--page-->
<div class="title">
	目录-升级指南
</div>
<div class="content">
	<ol>
		<li>url规则调整</li>
		<li>初始化配置</li>
		<li>事件</li>
		<li>location相关</li>
		<li>其它</li>
	</ol>
</div>

<!--page-->
<div class="title">
	目录-升级指南
</div>
<div class="content">
	<div class="main-sub">url规则调整</div>
</div>

<!--page-->
<div class="title">
	目录-升级指南-url规则调整
</div>
<div class="content text">
	<br />
	http://etao.com/#!/home<span class="red">/</span>a=b&c=d;调整为：<br /><br />
	http://etao.com/#!/home<span class="red">?</span>a=b&c=d;<br /><br />
	更好的区分<span class="red">/home</span>与<span class="red">/home/</span>：<br />
	http://etao.com/#!<span class="red">/home</span>?a=b&c=d;与<br />
	http://etao.com/#!<span class="red">/home/</span>?a=b&c=d;<br />
	是不一样的<br /><br />
	那么以后在a标签中写href时现在应该写：href="#!/home?a=b&c=d"<br /><br />
	这一步的调整也是为支持pushState进行做的修改(<a href="linkTo:core_code_router">router解释</a>)
</div>

<!--page-->
<div class="title">
	目录-升级指南
</div>
<div class="content">
	<div class="main-sub">初始化配置</div>
</div>

<!--page-->
<div class="title">
	目录-升级指南-初始化配置
</div>
<div class="content text">
	<br />
	首先去掉了app/config/ini文件<br />
	其次magix初始化入口修改如下（配置信息在入口处）<br />
	Magix.start({<br />
	　　appHome:"app",//应用目录，相对，绝对均可<br />
	　　release:false,//是否发布，上线后修改为true<br />
	　　pathCfg:{//路径映射配置<br />
	　　　　defaultView:'app/views/index',<br />
	　　　　defaultPathname:'/ppt',<br />
	　　　　map:{//view映射pathname<br />
	　　　　　　'app/views/index':['/ppt']<br />
	　　　　}<br />
	　　}<br />
	});<br />
	<a href="http://magixjs.github.com/doc/symbols/Magix.html#.start" target="_blank">参考API</a>
</div>

<!--page-->
<div class="title">
	目录-升级指南
</div>
<div class="content">
	<div class="main-sub">事件</div>
</div>

<!--page-->
<div class="title">
	目录-升级指南-事件
</div>
<div class="content text" style="font-size:140%">
	事件处理函数修改：<br />
	events:{<br />
	　　click:{<br />
	　　　　name:function(view,target,params){<br />
	　　　　　　//TODO<br />
	　　　　}<br />
	　　}<br />
	}<br />
	修改为：<br />
	events:{<br />
	　　click:{<br />
	　　　　name:function(e){//事件e对象参考API<br />
	　　　　　　//TODO<br />
	　　　　}<br />
	　　}<br />
	}<br />
</div>

<!--page-->
<div class="title">
	目录-升级指南-事件
</div>
<div class="content text" style="font-size:140%">
	<br />
	页面修改：<br />
	&lt;a href="#!/home" mxclick="name:params:_preventDefault_"&gt;x&lt;/a&gt;<br />
	修改为：<br />
	&lt;a href="#!/home" mxclick="name:params:_prevent_"&gt;x&lt;/a&gt;<br />
	_stop_和_halt_保持原来的不变<br /><br />
</div>

<!--page-->
<div class="title">
	目录-升级指南-事件
</div>
<div class="content text" style="font-size:140%">
	<br />
	新加入的功能：<br />
	&lt;a href="#!/home" mxclick="name:xinglie@name:58782@userId:_prevent_"&gt;x&lt;/a&gt;<br />
	<br />
	在写事件参数时，后面跟上@key，可以在事件处理函数内:<br />
	function(e){<br />
	　　console.log(e.params.name);<br />
	　　console.log(e.params.userId);<br />
	}<br />
	对比原来的params[0],params[1]在阅读源码时可给予帮助，那么当你的参数里面包含@时怎么办？
</div>

<!--page-->
<div class="title">
	目录-升级指南-事件
</div>
<div class="content text" style="font-size:140%">
	<br />
	比如下面这样：<br />
	&lt;a href="#!/home" mxclick="name:xinglie.lkf@taobao.com@name:58782@userId:_prevent_"&gt;x&lt;/a&gt;<br />
	<br />
	首先你用e.params.name是可以取出来前面的邮箱地址的，以最后一个@为准<br /><br />
	如果你继续沿用原来数组取值方式，并没有使用@key的新形式时，如：<br />
	&lt;a href="#!/home" mxclick="name:xinglie.lkf@taobao.com:58782:_prevent_"&gt;x&lt;/a&gt;<br />
	你用e.params[0],e.params[1]依然可以取得到对应的值，这块是向上兼容的，@key只是在保持原来不变的情况下，尽可能的方便开发人员
</div>

<!--page-->
<a name="core_upgrade_event_mu"></a>
<div class="title">
	目录-升级指南-事件
</div>
<div class="content text" style="font-size:140%">
	&lt;vframe id="magix_main"&gt;<br />
	　　&lt;button mxclick="change"&gt; change &lt;/button&gt;<br />
	　　&lt;vframe id="magix_vf1"&gt;<br />
	　　　　&lt;button mxclick="change"&gt; change &lt;/button&gt;<br />
	　　&lt;/vframe&gt;<br />
	&lt;/vframe&gt;<br />
	<br />
	前面提到的这段代码是有隐患的，重构中也解决了问题，但有时候你就是利用事件冒泡的特性让当前view的一些事件在父view中处理时怎么办？上面代码中button的mxclick默认是调用magix_vf1中的事件处理程序，如果您想让button的mxclick由父view magix_main处理时可以这样：<br />
	&lt;button mxclick="change" data-handler="magix_main"&gt; change &lt;/button&gt;指定处理的父view的vframe的id即可<br />
	此时只调用magix_main中的change处理函数，并不会调用magix_vf1中的 data-handler="magix_main,magix_vf1" 这样2个view都可以处理
</div>

<!--page-->
<div class="title">
	目录-升级指南
</div>
<div class="content">
	<div class="main-sub">location相关</div>
</div>

<!--page-->
<div class="title">
	目录-升级指南-location相关
</div>
<div class="content text">
	首先去掉了view的queryModel属性，跟本次的设计有关。当需要访问地址栏参数时，请使用view的getLocation()方法，同时也避免了直接访问queryModel绑定changed事件带来的隐患。<a href="http://magixjs.github.com/doc/symbols/View.html#getLocation" target="_blank">查看getLocation API</a><br /><br />
	同时view的queryModelChange(qm)方法修改为<span class="red bold">locationChange(e)</span>(<a href="http://magixjs.github.com/doc/symbols/View.html#locationChange" target="_blank">参考API</a>)<br /><br />
	原来的observeHash(params)方法修改为<span class="red bold">observeLocation(params,observePathname)</span>(<a href="http://magixjs.github.com/doc/symbols/View.html#observeLocation" target="_blank">参考API</a>)<br /><br />
	关于observeLocation的方法设计请参考代码细节与风险
</div>

<!--page-->
<div class="title">
	目录-升级指南
</div>
<div class="content">
	<div class="main-sub">其它</div>
</div>

<!--page-->
<div class="title">
	目录-升级指南-其它
</div>
<div class="content text" style="font-size:140%">
	<br /><br />
	&lt;vframe <span class="red bold">view_name</span>="app/views/list"&gt;&lt;/vframe&gt;
	<br />修改为：<br />
	&lt;vframe <span class="red bold">data-view</span>="app/views/list"&gt;&lt;/vframe&gt;<br /><br />
	原来默认的根view节点id <span class="red bold">vf-root</span>修改为：<span class="red bold">magix_vf_root</span>
</div>

<!--page-->
<div class="title">
	目录-升级指南-其它
</div>
<div class="content text" style="font-size:140%">
	<br /><br />
	改进的created refresh prerender rendered destroy事件
	<br /><br />
	view中新增childrenCreated事件及childrenAlter
	<br /><br />
	<a href="http://magixjs.github.com/doc/symbols/View.html" target="_blank">详见API</a>
</div>

<!--page-->
<div class="title">
	目录
</div>
<div class="content">
	<div class="main-sub">代码细节与风险</div>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险
</div>
<div class="content">
	<ol>
		<li>pathname配置</li>
		<li>Router</li>
		<li>VOM</li>
		<li>Vframe</li>
		<li>View</li>
	</ol>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险
</div>
<div class="content">
	<div class="main-sub">pathname配置</div>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-pathname配置
</div>
<div class="content text">
	<br />
	我们已经把配置信息从app/config/ini中转移到页面入口处了，首先谈一下为什么去掉文件并放在入口处：<br /><br />
	1. 文件是硬性的，新建app时必须指定，感觉不灵活<br />
	2. 有一些配置项可能是后台输出的，如果用原来的配置文件方式，需要先在页面上把配置项输出，在配置文件中再读取进来<br />
	3. 我的弹性配置目标，减少配置或不配置
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-pathname配置
</div>
<div class="content text">
	<br />
	原来pathname与view之间的映射配置：<br />
	假设这样的地址：http://etao.com/#!/home/a=b&c=d;<br />
	其实hash中的pathname为 /home 所以我们在配置 /home 要渲染哪个view时：<br />
	pathViewMap:{<br />
	　　"/home":"app/views/layouts/default"<br />
	}<br />
	假设还有一个/index也需要渲染这个default view时：<br />
	pathViewMap:{<br />
	　　"/home":"app/views/layouts/default",<br />
	　　"/list":"app/views/layouts/default"<br />
	}<br />
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-pathname配置
</div>
<div class="content text">
	<br />
	思考：<br />
	1. 对于前端来讲，什么才是真实的？<br />
	　app/views/layouts/default才是真实的，/home /list这些都是我们虚拟出来的，只是一个占位符<br />
	2. 一个真实的只有一个，虚拟的可以有几个？<br />
	　虚拟的可以有无数个，正如你上面看到的/home /list都对应真实的default这个view<br /><br />
	控制权反转：<br />
	只有先存在真实的，才能用真实的去映射出虚拟的：<br />
	"app/views/layouts/default":["/home","/list"]<br />
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-pathname配置
</div>
<div class="content text">
	<br />
	经过这样处理后，我们会发现原来的问题已经不再是问题，原因就是：<br />
	<span class="red">真实的个数&lt;=虚拟的个数</span><br />
	而且在支持pushState后，有些问题原来的配置方式是无解的：<br />
	假设服务器可以正确渲染这样的url：<br />
	http://etao.com/list?page=20;<br />
	那么当翻页的时候，支持pushState的浏览器上会变成这样：<br />
	http://etao.com/list?page=21;<br />
	这原本是没有问题的，那么当服务器端启用了url重写，变成了这样：<br />
	http://etao.com/list/20;时，问题就来了
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-pathname配置
</div>
<div class="content text">
	<br />
	http://etao.com/list?page=20;<br />
	对于这样的url，它的pathname是/list<br />
	<br />
	http://etao.com/list/20;<br />
	这样的url，它的pathname是/list/20<br />
	而多少页是不定的，因此你无法这样去配置：<br />
	"/list/1":"app/views/layouts/default",<br />
	"/list/2":"app/views/layouts/default"<br /><br />
	而通过反转后的是可以的：<br />
	"app/views/layouts/default":/^\list/\d+$/i<br />
	支持正则表达式
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-pathname配置
</div>
<div class="content text">
	notFound弹性配置
	<br />
	Magix.start({<br />
	　　appHome:"app",//应用目录，相对，绝对均可<br />
	　　release:false,//是否发布，上线后修改为true<br />
	　　pathCfg:{//路径映射配置<br />
	　　　　defaultView:'app/views/index',<br />
	　　　　defaultPathname:'/ppt',<br />
	　　　　<span class="red bold">notFound:"app/views/404",</span><br />
	　　　　map:{//view映射pathname<br />
	　　　　　　'app/views/index':['/ppt']<br />
	　　　　}<br />
	　　}<br />
	});<br />
	notFound非必须配置项，当你配置之后，如果pathname对应不上view则显示你指定的404 view，未配置显示defaultView所指定的view
</div>


<!--page-->
<div class="title">
	目录-代码细节与风险-pathname配置
</div>
<div class="content text">
	defaultPathname弹性配置
	<br />
	Magix.start({<br />
	　　appHome:"app",//应用目录，相对，绝对均可<br />
	　　release:false,//是否发布，上线后修改为true<br />
	　　pathCfg:{//路径映射配置<br />
	　　　　defaultView:'app/views/index',<br />
	　　　　<span class="red bold">defaultPathname:'/ppt',</span><br />
	　　　　map:{//view映射pathname<br />
	　　　　　　'app/views/index':['/ppt']<br />
	　　　　}<br />
	　　}<br />
	});<br />
	defaultPathname同样是非必须配置项，当你未配置时，默认会找到defaultView对应的第1个虚拟路径做为默认的pathname，即上述代码中的 /ppt
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-pathname配置
</div>
<div class="content text">
	关于弹性配置的设计：<br /><br />
	1. 减少硬性配置，减轻开发人员的记忆负担<br />
	2. 依据开发人员的习惯，进行设计，即使忘记配置某些项，上线后也不会照成较大的问题
</div>

<!--page-->
<a name="core_code_router"></a>
<div class="title">
	目录-代码细节与风险
</div>
<div class="content">
	<div class="main-sub">Router</div>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	Router加入对history state的支持，但history state浏览器之间有差异<br />
	webkit浏览器在刷新时会触发一次pop事件，其它浏览器则不会<br />
	<br />
	magix/router解决方案：<br />
	绑定pop事件前记录下当前页面的url，pop事件后，判断2个url是否一样，如果不一样则说明是调用history pushState进行了修改，当然通过pushState也有可能push一个和初始时一样的url，因此程序中还需要记录下有没有在pop事件触发后，进行过后面的调用，如果已经调用过则就算url一样也是需要向下派发事件的
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	加入history state后，默认是不启用的，如果需要启用，在Magix.start时需要如下配置：<br />
	Magix.start({<br />
	　　appHome:"app",//应用目录，相对，绝对均可<br />
	　　release:false,//是否发布，上线后修改为true<br />
	　　<span class="red bold">useHistoryState:true,</span><br />
	　　pathCfg:{//路径映射配置<br />
	　　　　defaultView:'app/views/index',<br />
	　　　　defaultPathname:'/ppt',<br />
	　　　　map:{//view映射pathname<br />
	　　　　　　'app/views/index':['/ppt']<br />
	　　　　}<br />
	　　}<br />
	});<br />
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	<br />
	当启用history state之后，如何确定url中的pathname?<br /><br />
	http://etao.com/list?page=20;<br /><br />
	因为您明确指定了使用history state则在所有浏览器中pathname均为/list<br />
	当您未启用history state时，则表示使用hash，但上述url中并没有hash，此时使用Magix.start配置信息中，pathCfg.defaultPathname来做为当前的pathname，以上页的代码为例，在没有启用history state，并且hash为空的情况下，pathname默认为 /ppt
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	我们为什么一定要默认一个pathname？为空不行吗？<br /><br />
	重构完成后，是有一段时间pathname可以为空，但这样会给app开发者带来学习负担，比如要通过pathname确定一些判断时：<br />
	var loc=this.getLocation();<br />
	if(loc.pathname==''||loc.pathname=='/home')这种判断就变得复杂，假如pathname必定会有一个值，那就方便很多。<br /><br />
	但这样就要求在使用hash时，配置信息中要有一个defaultPathname，又与我们的弹性配置有点冲突，经过权衡后，决定步子还是不要一下迈的太大，不要一下子改变以前所有的习惯，所以就必须有pathname了<br /><br />
	当然在使用history state时，是不必纠结这个问题的
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	当启用history state之后，您需要确保后台能够按相关的参数正确渲染，如下面的url：<br />
	http://etao.com/list?page=20;<br />
	当您调用Router.navigate方法添加新的参数时，比如：<br />
	Router.navigate({<br />
	　　rows:30<br />
	});<br />
	这时候url会变成：http://etao.com/list?page=20&rows=30;<br />
	如果在不支持history state的浏览器上，比如IE，则会变成：http://etao.com/list?page=20#!/list?rows=30;
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	<br />
	我们观察下这个url：http://etao.com/list?page=20#!/list?rows=30;<br />
	<br />
	query中的pathname与参数是：/list?page=20<br />
	hash中的pathname与参数是：/list?rows=30<br />
	<br />
	它们在格式上是一致的，这也是重构时为什么把/list/rows=30中的/变?的原因，统一后也更容易理解些，避免不统一带来的学习成本增大<br />
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	<br />
	我们再观察下这个url：http://etao.com/list?page=20#!/home?rows=30;<br />
	<br />
	query中的pathname与参数是：/list?page=20<br />
	hash中的pathname与参数是：/home?rows=30<br />
	<br />
	都有pathname，且不相同，这时候magix/router如何处理？pathname用谁的？<br />
	1. 如果用户明确指定了当前app使用history state即useHistoryState为true:<br />
	　　优先使用hash中的pathname，因为有可能是从不支持history state浏览器上拷贝链接到支持的浏览器上，如果hash中存在pathname则使用hash中的，否则用query中的<br />
	2. 如果指定不用history state则直接使用hash中的pathname，不能使用query中的，这样能才与原来直接使用hash保持一致
</div>


<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	<br />
	我们再次观察下这个url：http://etao.com/list?page=20&rows=30;<br /><br />
	导航这个url：Router.navigate('/list?page=1');<br />
	假设我们使用history state，并且当前浏览器支持，于是url会变成：http://etao.com/list?page=1;page参数改变，同时丢掉了rows参数，这是合理的<br /><br />
	当在不支持history state的浏览器上时，url会变成：http://etao.com/list?page=20&rows=30#!/list?page=1&rows=;<br /><br />
	我们需要把清除的参数从前面取出来，放在hash中进行清除，下页会讲到参数的合并问题
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	http://etao.com/list?page=20&rows=30#!/list?page=1&rows=;<br />
	对于这个url，不管用户有没有启用history state，都可以把hash中的参数merge到query中去，其实这个动作是有风险的，比如说：<br /><br />
	http://etao.com/list?page=20&rows=30#!page=b<br /><br />
	用户就是要放一个!page=b的hash，但是这样考虑会把问题过于复杂化，跟木头也讨论过，所以现阶段不考虑这种hash，认为所有的hash都是我们自已放上去的，因此对于hash与query中的参数直接拿hash中的merge到query中即可，同名的覆盖掉query中的<br /><br />
	因此上述url解析出来的参数为:{page:1,rows:''}，跟http://etao.com/list?page=1;解析出来的参数并不完全一样{page:1}，后者没有rows，不过在最终的使用上是一样的，这是一处不太大的风险，下页会讲
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	假设当前使用history state则从http://etao.com/list?page=20&rows=30;跳转到http://etao.com/list?page=1时<br /><br />支持history state的浏览器直接变成：<br />
	http://etao.com/list?page=1<br />
	不支持history state的浏览器上会变成：<br />
	http://etao.com/list?page=20&rows=30#!/list?page=1&rows=;<br /><br />
	前者解析出来的参数为:{page:1},后者为:{page:1,rows:''}，相对于原来的url解析出来的参数{page:20,rows:30}，都是改变了参数page和rows，这是没问题的<br />
	<br />
	只是从参数中取rows时，第1种是undefined，第2种是空字符串，严格来讲这是有问题的，不过在具体使用上并不会引入太大的问题(从地址栏中拿到的参数都是需要校验的)，所以暂忽略掉这个风险
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	<br />
	关于连续调用Router.navigate的问题：<br />
	比如：<br />
	Router.navigate('a=b&c=d');<br />
	Router.navigate('e=f&g=h');<br />
	这种之前是有问题的，<a href="linkTo:core_problems_router_mu">见前面的(location.hash)问题;</a>参考<br />
	magix/router通过排队的方式来实现对连续调用参数的保持，避免丢失参数，同时在合适的时候派发idle事件，VOM通过监听该事件再调用view挂起的方法，进而保证可以在相关的方法内拿到地址栏上的参数(参考<a href="linkTo:core_result_rvr">Router与VOM之间的关系</a>，<a href="linkTo:core_code_view_suspend">View挂起</a>)
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	<br />
	magix/router suspend与resume问题：<br /><br />
	当router调用resume时，有可能已经堆积n多个回调，此时应该是一个一个回调还是一次性全部调用？当然在回调中依然有可能造成router suspend(从目前的代码看必然造成suspend)。
	<br /><br />不能一个一个调用，因为在调用时，有可能第一个执行了，后面的又进入排队了，会造成任务列表一直有，调用不到头。再一个是为了保持与VOM中设计的统一，该处采取了一次性调用完这个任务列表，在调用中该排队时仍然去排队，但跟本次的一次性调用无关<br /><br />
	<spa class="red">在hashchange事件中也需要挂起，考虑点击a(href="#!/list")标签后，又在locationChange中通过Router.navigate修改了参数，会导致修改的参数被href覆盖，也是异步的问题</spa>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Router
</div>
<div class="content text">
	<br />
	关于router对解析的url缓存的设计：<br /><br />
	router会对解析过的url缓存，下次解析时直接使用缓存结果，用空间换时间，主要原因是访问同一个url的次数非常多，而在应用中，不同的url个数比较少，对于后期不同url膨胀问题，会对缓存这块进行升级，升级方案为：缓存指定的个数，比如只缓存20个，当超过20个时，从原来的20个中删除使用次数最小的
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险
</div>
<div class="content">
	<div class="main-sub">VOM</div>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-VOM
</div>
<div class="content text">
	VOM提供对Vframe的管理，整体来讲并没有什么难点，在这里说下suspend、resume与idle的设计:<br /><br />
	VOM作为整个页面区块(view)的调度中心，所有view之间发送的消息，访问的方法都要经过这里，虽然它设计的简单，却是一个重要的角色。<br /><br />
	在设计suspend时，采用的是累加计数的方式，即有可能挂起很多次(为什么要挂起？<a href="linkTo:core_code_view_suspend">参考这里</a>)，为什么？一方面VOM需要监听来自Router的busy与idle进行相应的挂起与继续，一方面是来自view的渲染，也会造成VOM挂起整个区块间的消息传递，消息来源并不一致，所以采取计数累加的方式
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-VOM
</div>
<div class="content text">
	<br />
	为什么不把来自router与vframe的挂起消息分开设计呢?<br /><br />
	1. 显然分开设计会导致代码较复杂<br />
	2. 这个挂起的过程是瞬间的，并不是持久的<br />
	3. 不管来自哪里的消息，最终的目的是一致的<br /><br />
	基于以上原因，个人认为没必要分开设计，合并后更能表达出它的意图：当有些操作影响到view间的消息或方法调用时，停来下等待这些操作的完成，完成后再传递消息或方法调用，确保view始终处于安全的状态
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险
</div>
<div class="content">
	<div class="main-sub">Vframe</div>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Vframe
</div>
<div class="content text">
	关于view的加载：<br /><br />
	view文件的加载是异步的，有可能在view加载完成时，vframe已经销毁，因此需要进行一次判断。而在该处设计时，并不是像view一样提供一个exist属性标识当前vframe对象是否已经销毁，而是使用viewName属性进行标识：<br /><br />
	1. 当vframe被销毁时，会删除viewName属性，在view加载成功后会判断是否存在该属性<br />
	2. 当vframe重新渲染其它view时，会重置viewName，在view加载成功后，会判断是否跟当前vframe的viewName一致，如果不一致则不再渲染<br /><br />
	可能用同一个vframe对象加载不同的view，设计viewName属性，可以标识当前加载的view，同时解决了销毁与加载别的view时的判断问题
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Vframe
</div>
<div class="content text">
	关于childrenCreated与childrenAlter事件：<br /><br />
	虽然这2个事件是在view中派发的，但实现却是在vframe实现的，先说设计再说问题：<br />
	设计在view中派发，是因为在应用开发中，开发者只关注view即可，几乎不与VOM和Vframe打交道，因此在view中派发，更能方便开发人员，view就是设计给开发人员用的，VOM和Vframe是magix管理这些view用的。
	<br /><br />
	而magix在实现这2个事件时，却是在vframe中。这是因为view仅负责展示当前区块的内容，vframe负责上下的父子关系，VOM负责管理所有的vframe，所以很明显子view有什么动作，负责父子的vframe才最清楚，因此实现是在vframe中实现的
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Vframe
</div>
<div class="content text">
	关于childrenCreated与childrenAlter事件问题：<br /><br />
	先说childrenCreated，<span class="red">所有子及孙view的created事件触发后</span>会触发childrenCreated事件，当view不包含任何子view时，也会触发childrenCreated事件。在实现时，并未在vframe中绑定view的created事件进行监听，而是在loadSubVframes中进行判断的，当在view中找不到vframe标签时，即触发当前view的childrenCreated事件，然后依次向上派发<br /><br />
	风险：loadSubVframes有可能不被调用，比如你指定当前view有模板，但并未调用setViewHTML进行渲染view内容，那么此时将无法正常派发childrenCreated事件，在该情况下vie的created事件同样无法触发，因此上面的设计绑定created事件也是不行的。view没有模板时并不存在该问题
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Vframe
</div>
<div class="content text">
	关于childrenCreated与childrenAlter事件问题：<br /><br />
	再说childrenAlter，<span class="red">当子及孙view任意一个重新mountView或刷新时</span>，会触发childrenAlter，所以该事件会被触发多次，比如你同时重新mount了2个子view。<br />
	当刷新或mount完毕后，会再次触发childrenCreated事件，因此这2个事件均是多次触发的<br /><br />
	风险：这2个事件是为了解决复杂应用而设计的，因为是新方法，所以可能会存在问题，需要开发者注意下，及时反馈
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Vframe
</div>
<div class="content text">
	关于view的postMessageTo，该方法也是在vframe中实现的，跨view传递消息，本来设计在VOM才是正确的，但目前设计在了vframe中，这个我并没有理由，所以这块可能会再调整一下<br /><br />
	说一下在什么情况下消息才会被投递给另外一个view：<br />
	投递的目标view的vframe存在，vframe存在有可能view还不存在，比如view正在加载中，所以除了vframe存在外，还需要vframe的viewName属性也要存在，只有这样能正传递消息，否则就会丢弃这个消息
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Vframe
</div>
<div class="content text">
	vframe在渲染子view时，是采取挂起整个VOM的方式，即会临时中断view之间的消息传递和view部分方法对locationChange事件的接收<br /><br />
	为什么要挂起？<br />
	&lt;vframe data-view="app/views/main" id="J_main"&gt;<br />
	　　&lt;vframe data-view="app/view/left" id="J_left"&gt;&lt;/vframe&gt;<br />
	　　&lt;vframe data-view="app/view/right" id="J_right"&gt;&lt;/vframe&gt;<br />
	&lt;/vframe&gt;<br />
	考虑缓存的情况下，非缓存的不考虑：<br />
	渲染时，J_main渲染后，发现子view left和right，在渲染子view时，是顺序渲染的，所以先渲染left,在left的render中假如我们要postMessageTo right(因为相关模板数据都是缓存的，所以代码顺序执行)，而此时还没渲染到right，所以这个消息肯定发送不成功
</div>


<!--page-->
<div class="title">
	目录-代码细节与风险-Vframe
</div>
<div class="content text">
	如果未挂起vframe在mount left时，load left后，view.render(suspend)->delegate events->callback(suspend)->fire ready->(vframe listener)->left(resume)->render(find right->NULL)->callback<br />
	挂起后：<br />
	vframe loadSubVframes:<br />
	leftVframe->loadLeftView->leftViewSuspend->render(suspend)->delegate evetns->callback(suspend)->fire ready->(vframe listener)->leftViewResume->..外界仍然挂起，leftView挂起的render callback不执行
	<br />
	rightVframe->loadRightView->rightViewSuspend->render(suspend)->delegate events->callback(suspend)->fire ready->(vframe listener)->rightViewResume->..<br /><br />
	vframe resume<br />
	leftRender leftCallback rightRender rightCallback，消息得以顺利投递
</div>

<!--page-->
<a name="core_code_anim"></a>
<div class="title">
	目录-代码细节与风险-Vframe
</div>
<div class="content text">
	关于动画的设计：<br />
	动画分2种，一种是同一个vframe渲染不同的view时，一种是view刷新时<br /><br />
	控制有没有动画有2处控制，一处是在Magix.start时，配置参数viewChangeAnim来决定是否整个app在view切换时使用动画，一处是在各个view的类中配置enableRefreshAnim来决定是否启用刷新动画。前者起决定性的作用，后者是辅助的，这块后面将探讨引入的问题<br /><br />
	动画的整个实现是在vframe中实现的，在实现时，vframe中把是否使用动画用方法来配置，而view中用属性来配置，具体原因见下页：
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Vframe
</div>
<div class="content text">
	vframe中设计为方法，主要是因为vframe并不对外，因此在实现时，通过方法的返回值来决定是否启用动画，这样可以更有针对性的对某几个vframe使用动画<br /><br />
	view中设计为属性是因为开发人员本身访问这个属性就比较方便 ，如果设计为方法会增加使用难度，远不如一个配置来的方便些，同时view的刷新动画默认是不启用的，具体原因见下页：
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-Vframe
</div>
<div class="content text">
    转场动画仅适用对于同一个vframe渲染不同view时较安全，因为转场时页面上会同时存在
	这2个view的html内容，而在view内部DOM操作时选择器通常不会意外的选择到其它节点上<br /><br />
	
	对于view的刷新不建议使用动画，因为2个view的html内容一样，DOM选择很容易发生失误
	如果您需要view在刷新时使用动画，最好在代码中DOM选择器都加上id<br /><br />
	类似：<br />
	
	render:function(){<br />
	　　var inputs=S.all('#'+this.id+' input');//加上id限定<br />
	}
</div>


<!--page-->
<div class="title">
	目录-代码细节与风险
</div>
<div class="content">
	<div class="main-sub">View</div>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	开始使用view的注意点：<br /><br />
	现在使用view在继承时，请<span class="red bold">一定</span>按照下面的格式进行继承：<br />
	return <span class="red">MxView.extend</span>({<br />
	　　init:function(){<br />
	　　　　this.observeLocation('page,rows');<br />
	　　},<br />
	　　locationChange:function(){<br />
	　　　　this.render();<br />
	　　},<br />
	　　render:function(){<br />
	　　　　//...<br />
	　　}<br />
	});<br />
	
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	view的init方法调用时间点：<br />
	<br />
	在当前view没有模板文件的情况下:<br />
	new -> base ctor -> view ctor -> load -> init -> interact(事件) -> render  -> created(事件)<br /><br />
	view 有模板无缓存，调用render方法时，同步调用setViewHTML：<br />
	new -> base cotr ->  view ctor -> load -> getTmpl -> init -> interact(事件) -> render -> setViewHTML -> prerender(事件) -> rendered(事件) -> created(事件)
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	view的init方法调用时间点：<br />
	<br />
	view 有模板无缓存，调用render方法时，异步调用setViewHTML：<br />
	new -> base cotr ->  view ctor -> load -> getTmpl -> init -> interact(事件) -> render -> setViewHTML -> prerender(事件) -> rendered(事件) -> created(事件) <br /><br />

	view 有模板有缓存， 调用render方法时，同步调用setViewHTML：<br />
	new -> base ctor -> view ctor -> load -> getTmpl -> init  -> interact(事件) -> render -> setViewHTML -> prerender(事件) -> rendered(事件) -> created(事件)
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	view的init方法调用时间点：<br />
	<br />
	view 有模板有缓存， 调用render方法时，异步调用setViewHTML：<br />
	new -> base ctor -> view ctor -> load -> getTmpl -> init -> interact(事件) -> render -> setViewHTML -> prerender(事件) -> rendered(事件)  -> created(事件)<br /><br />
	<span class="red">通过以上的初始化过程，我们会发现，新版本的init的调用时间点并不像老版本那样在构造时调用，而是向后推迟了</span>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	为什么推迟view的init方法的调用：<br />
	<br />
	1. view的整个初始化过程正如前面看到的，情况多，需求复杂，而init又是提供给开发人员覆盖重写的，因此具体的情况会更复杂，为了减少用户在init中出现问题，因此推迟到interact事件前才调用(后面会讲interact事件的设计)<br />
	2. 推迟init事件的调用，并不会引入其它问题，相反能够帮使你在init方法中访问到其它资源，不必去绑定某些事件后在回调中去处理<br />
	3. 如果你一定要在构造时就做一些事情，仍然是可以做到的，这个不必担心哦，下页会讲init的其它问题
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text" style="font-size:140%">
	init推迟可能带来的问题：<br />
	<br />
	init受getTmpl方法的影响，在开发app时，获取模板是异步的，因此init是在获取完模板后才被调用的，那么在这个等待过程中，有locationChange或其它事件发生怎么办？如下代码<br />
	return MxView.extend({<br />
	　　init:function(){<br />
	　　　　this.observeLocation('page,rows');<br />
	　　},<br />
	　　locationChange:function(){<br />
	　　　　this.render();<br />
	　　},<br />
	　　render:function(){<br />
	　　　　//...<br />
	　　}<br />
	});<br />
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	<br />
	监控page和rows这2个参数的改变，有改变时重新渲染，当获取模板时间较长，而此时其它参数有变化（page rows没有变化），因init方法中指定监控的参数还未生效，此时会引起这个view的locationChange方法被调用，render会被多调用一次，但这不影响最终渲染的结果，一旦发布上线模板与js文件打包在一起时，获取模板的过程就是同步的了，也就不会再有这个重复渲染的问题，当然如果您介意这个问题，可以按下页的方式解决这个问题
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	return MxView.extend({<br />
	　　locationChange:function(){<br />
	　　　　this.render();<br />
	　　},<br />
	　　render:function(){<br />
	　　　　//...<br />
	　　}<br />
	},funciton(){//在构造方法内进行监控，而不是在init方法内<br />
	　　this.observeLocation('page,rows')<br />
	});<br />
	<br />
	这也是前面提到的可以在构造时做一些事情，但不推荐这样做
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	init方法为什么会设计的这么靠后？<br /><br />
	view没被创建出来前，是不能做其它动作的，如果在此之前调用了init，而用户可以在init中做其它的动作，假设view还未创建完成就销毁，会给销毁带来一定的麻烦<br /><br />
	通常在init中还会访问其它对象，因此放在interact事件后，接下来讲解interact事件的设计(同时您也将看到为什么init不放在created事件之后，init是放在interact可交互之后立即被调用，既不会太靠前，也不会太靠后)
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	view的interact事件：<br /><br />
	这是一个不推荐在外部使用的事件，仅magix内部使用，当然外部也可以用，API文档上就不再体现了<br /><br />
	interact : view准备好，让外部尽早介入，进行其它事件的监听 ，当interact事件触发时，view有可能已经有html了(无模板的情况)，所以此时外部可以去加载相应的子view了，同时要考虑在调用render方法后，有可能在该方法内通过setViewHTML更新html，所以在使用setViewHTML更新界面前，一定要先监听prerender rendered事件，因此设计了该  interact事件，在该事件内，去监听别的事件
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	风险：view的init与created事件：<br /><br />
	init尽可能早的被调用，以完成相关的事件绑定和location监控，但这并不意味着init被调用时，created事件一定被触发，或在init后created事件才被触发，如前面所看到的初始化流程，由于应用的复杂性，这2个的先后是不定的，因此如果您需要在init中首次创建完界面做一些事情时，可参考以下代码：<br />
	init:function(){<br />
	　　if(this.rendered){//已渲染完成<br />
	　　　　//TODO<br />
	　　}else{<br />
	　　　　this.bind('created',function(){//绑定created事件<br />
	　　　　　　//TODO<br />
	　　　　})<br />
	　　}<br />
	}<br />
</div>

<!--page-->
<a name="core_code_view_suspend"></a>
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	view的suspend与resume设计：<br /><br />
	挂起view的部分方法的执行，等待其它操作的完成，同时在使用view的idle方法时，所有的回调也会被挂起，下页讲解view为什么要挂起一些方法的执行
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	&lt;vframe id="magix_vf_root"&gt;<br />
	　　&lt;## &lt;vframe id="magix_vf_1" data-view="..."&gt;&lt;/vframe&gt; ##&gt;<br />
	&lt;/vframe&lt;<br />
	&lt;## ##&gt;表示是magix_vf_root的view载入后，通过setViewHTML添加的<br /><br />
	在magix_vf_root的render中，如果要调用postMessageTo向vf_1发消息，vf_1接受不到，因为set完后，Vframe还没有建立起相应的vframe对象：<br />
	1.<span class="bold">当开发者重写了render方法</span>：base view -> delegate evetns -> interact(事件) -> vframe在ineteract回调处理时：view有模板时见@1，如果view无模板时见@2 -> render<br /><br />
	@1:bind prerender与rendered事件，当view调用setViewHTML更新view内容时，后续正确<br />
	@2:加载子view bind prerender与rendered事件..同@1
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	2.<span class="bold">当开发者未重写render方法</span>：<br />
	同1<br /><br />
	通常在render方法中如果是异步更新或访问postMessageTo等访问是没有问题的，如果是同步的就会找不到相应的vframe对象，加入suspend与resume后，vframe中的流程如下：<br />
	cache:inateract->(vframe.loadSubVframes)->render(postMessage,idle)->setViewHTML->(prerender,rendered)->(unload,loadSubVframes)->resume;
	
	nocache:interact->(vframe.loadSubVframes)->render(async back[postMessage idle])->resume()
			<br />
			tmplReady->setViewHTML->(prerender,rendered)->(unload,loadSubVframes)->postMessage idle
	<br /><span class="red">怎么说的这么烂...</span>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	<br />
	当view挂起时，postMessageTo等方法的调用并不是立即的，这样可以给外部足够的时间建立起相应的对象，当view运行挂起的这些方法时，会确保外部的资源已经就绪，这块跟view的初始化过程有很大的关系，初始化较复杂，因此设计了suspend与resume方法
</div>


<!--page-->
<a name="core_code_manage"></a>
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	关于view中托管资源的设计：<br /><br />
	理想中的情况是view中用到的匿名或回调函数、组件等其它资源，都应当托管到view这个对象上，这样view在刷新或销毁时，可自动帮你管理这些资源，防止您忘记释放带来的其它问题，同时对于方法，也可以做到防止意外的调用<br /><br />
	当您需要托管时，调用view的manage方法即可，<a href="http://magixjs.github.com/doc/symbols/View.html#manage" target="_blank">访问API</a>
</div>


<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	view的异步更新设计：<br />
	什么是异步更新html？<br />
	render:function(){<br />
	　　var _self=this;<br />
	　　var m=new Model({uri:'user:list'});<br />
	　　m.load({<br />
	　　　　success:_self.manage(function(data){<br />
	　　　　　　var html=Mu.to_html(_self.template,data);<br />
	　　　　　　_self.setViewHTML(html);<br />
	　　　　}),<br />
	　　　　error:_self.manage(function(msg){<br />
	　　　　　　_self.setViewHTML(msg);<br />
	　　　　})<br />
	　　})<br />
	}<br />
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	<br />
	如上所示，当调用render方法时，render方法内部使用model异步获取数据后才完成html的更新则这个render就是采用异步更新html的<br />
	异步更新带来的问题：<br />
	view对象监听地址栏中的某个参数，当这个参数发生变化时，view调用render方法进行刷新，因为是异步的，所以并不能立即更新界面，<br />
	 当监控的这个参数连续变化时，view会多次调用render方法进行刷新，由于异步，你并不能保证最后刷新时发出的异步请求最后返回，<br />
	 有可能先发出的请求后返回，这样就会出现界面与url并不符合的情况，比如tabs的切换和tabPanel的更新，连续点击tab1 tab2 tab3 <br />
	 会引起tabPanel这个view刷新，但是异步返回有可能3先回来2最后回来，会导致明明选中的是tab3，却显示着tab2的内容
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text" style="font-size:140%">
	所以要么你自已在回调中做判断，要么把上面的示例改写成下面这样的：<br />
	render:function(){<br />
	　　var _self=this;<br />
	　　<span class="red">_self.beginAsyncUpdate();</span>//开始异步更新<br />
	　　var m=new Model({uri:'user:list'});<br />
	　　m.load({<br />
	　　　　success:_self.manage(function(data){<br />
	　　　　　　var html=Mu.to_html(_self.template,data);<br />
	　　　　　　_self.setViewHTML(html);<br />
	　　　　}),<br />
	　　　　error:_self.manage(function(msg){<br />
	　　　　　　_self.setViewHTML(msg);<br />
	　　　　})<br />
	　　});<br />
	　　<span class="red">_self.endAsyncUpdate();</span>//结束异步更新<br />
	}<br />
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text" style="font-size:140%">
	当然如果在每个异步更新的都需要这样写的话来带来差劲的编码体验，所以View会对render,renderUI,updateUI三个方法自动进行异步更新包装<br />
	您在使用这三个方法异步更新html时无须调用beginAsyncUpdate和endAsyncUpdate方法
	如果除了这三个方法外你还要添加其它的异步更新方法，可调用View静态方法View.registerAsyncUpdateName来注册自已的方法<br />
	请优先考虑使用render renderUI updateUI <br />这三个方法来实现view的html更新，其中render方法magix会自动调用，您就考虑后2个方法吧<br />
	比如这样：
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text" style="font-size:140%">
	<br />
	<span class="red">renderUI</span>:function(){//当方法名为 render renderUI updateUI时您不需要考虑异步更新带来的问题<br />
	　　var _self=this;<br />
	　　setTimeout(this.manage(function(){<br />
	　　　　_self.setViewHTML(_self.template);<br />
	　　}),5000);<br />
	},<br />
	receiveMessage:function(e){<br />
	　　if(e.action=='render'){<br />
	　　　　this.renderUI();<br />
	　　}<br />
	}<br />
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text" style="font-size:140%">
	当您不想托管回调方法，又想消除异步更新带来的隐患时，可以这样：<br /><br />
	updateHTML:function(){<br />
	　　var _self=this;<br />
	　　<span class="red">var begin=_self.beginAsyncUpdate();</span>//记录异步更新标识<br />
	　　S.io({<br />
	　　　　success:function(html){<br />
	　　　　//if(_self.exist){//(使用异步更新标识时，不需要判断exist)<br />
	　　　　　　　　<span class="red">var end=_self.endAsyncUpdate();</span>//结束异步更新<br />
	　　　　　　　　if(begin==end){//一样，表示view没有刷新或销毁<br />
	　　　　　　　　　　_self.setViewHTML(html);<br />
	　　　　　　　　}<br />
	　　　　　　//}<br />
	　　　　}<br />
	　　});<br />
	}<br />
</div>


<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	然而不是所有的回调进行托管就万事大吉了，考虑下面的情况：<br /><br />
	<div style="height:380px;overflow:auto">
	render:function(){<br />
	　　ModelFactory.fetchAll({<br />
	　　　　type:'User_List',<br />
	　　　　cacheKey:'User_List'<br />
	　　},function(m){<br />
	　　　　//render<br />
	　　});<br />
	},<br />
	//...<br />
	click:{<br />
	　　addUser:function(e){<br />
	　　　　var m=ModelFactory.getIf('User_List');<br />
	　　　　var userList=m.get("userList");<br />
	　　　　m.beginTransaction();<br />
	　　　　userList.push({<br />
	　　　　　　id:'xinglie',<br />
	　　　　　　name:'xl'<br />
	　　　　});<br />
	　　　　m.save({<br />
	　　　　　　success:function(){//该回调不太适合托管<br />
	　　　　　　　　m.endTransaction();<br />
	　　　　　　　　Helper.tipMsg('添加成功')<br />
	　　　　　　},<br />
	　　　　　　error:function(msg){//该方法同样不适合托管，当数据保存失败时，需要回滚数据，而如果此时view有刷新或销毁，会导致该方法不被调用，无法达到数据的回滚<br />
	　　　　　　　　m.rollbackTransaction();<br />
	　　　　　　　　Helper.tipMsg('添加失败')<br />
	　　　　　　}<br />
	　　　　})<br />
	　　}<br />
	}</div>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	<br />
	正如前面代码中提到的，对托管的函数，一旦view有刷新或销毁，托管的函数是不会被调用的，而有些时候我们是期望回调中的部分代码还是需要继续被调用的，所以托管并不能解决掉所有问题，如果要解决前面的问题(回调中与界面无关的代码继续调用，与界面有关的代码需要在判断view有没有销毁或刷新后才调用)，因此该处引入了view的签名设计，可以通过对比2次view的签名是否一致来识别view有没有刷新或销毁，即前面的代码可以这样写：
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	<div style="height:400px;overflow:auto">
	render:function(){<br />
	　　ModelFactory.fetchAll({<br />
	　　　　type:'User_List',<br />
	　　　　cacheKey:'User_List'<br />
	　　},function(m){<br />
	　　　　//render<br />
	　　});<br />
	},<br />
	//...<br />
	click:{<br />
	　　addUser:function(e){<br />
	　　　　var m=ModelFactory.getIf('User_List');<br />
	　　　　var userList=m.get("userList");<br />
	　　　　m.beginTransaction();<br />
	　　　　userList.push({<br />
	　　　　　　id:'xinglie',<br />
	　　　　　　name:'xl'<br />
	　　　　});<br />
	　　　　<span class="red bold">var sign=e.view.signature();</span>//获取签名<br />
	　　　　m.save({<br />
	　　　　　　success:function(){//该回调不太适合托管<br />
	　　　　　　　　m.endTransaction();<br />
	　　　　　　　　<span class="red bold">if(sign==e.view.signature()){</span>//相等时表示view即没刷新也没销毁，此时才提示<br />
	　　　　　　　　　　Helper.tipMsg('添加成功')<br />
	　　　　　　　　<span class="red bold">}</span><br />
	　　　　　　},<br />
	　　　　　　error:function(msg){//该方法同样不适合托管，当数据保存失败时，需要回滚数据，而如果此时view有刷新或销毁，会导致该方法不被调用，无法达到数据的回滚<br />
	　　　　　　　　m.rollbackTransaction();<br />
		　　　　　　　　<span class="red bold">if(sign==e.view.signature()){</span><br />
	　　　　　　　　　　Helper.tipMsg('添加失败')<br />
	　　　　　　　　<span class="red bold">}</span><br />
	　　　　　　}<br />
	　　　　})<br />
	　　}<br />
	}</div>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	如果您托管mxext/model对象后，无须再托管回调函数，如下：<br />
	render:function(){<br />
	　　var _self=this;<br />
	　　var m=new Model({uri:'user:list'});<br />
	　　m.load({<br />
	　　　　success:function(data){<br />
	　　　　　　var html=Mu.to_html(_self.template,data);<br />
	　　　　　　_self.setViewHTML(html);<br />
	　　　　},<br />
	　　　　error:function(msg){<br />
	　　　　　　_self.setViewHTML(msg);<br />
	　　　　}<br />
	　　})<br />
	　　<span class="red bold">_self.manage(m);</span>//托管model对象后无须托管model的回调<br />
	}<br />
</div>

<!--page-->
<a name="core_code_habit"></a>
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	关于开发人员编程习惯的考虑与设计：<br /><br />
	正如你前面看到的<span class="red bold">_self.manage(m);</span>magix本身来讲已经提供了manage管理回调函数，并且能很好的解决问题，那为什么还会有托管model对象？通常来讲，写异步，写回调是每个前端开发人员都少不了的，但从来没有在哪个地方需要对回调托管，开发人员已经习惯顺手写一个函数，而不是顺手写一个manage里面再写一个函数。<br /><br />
	改变习惯很难，就算改，也不可能一下子转变过来，肯定会有疏忽，有遗漏，引导并建立新的习惯，这样开发人员才乐于接受。这块在闲聊分享时会做重点举例和讲解
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	<br /><br />
	<span class="red bold">如果您无法识别出哪些方法需要托管，哪些适合签名，请统一使用托管</span>
</div>

<!--page-->
<a name="core_code_habit"></a>
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	关于开发人员编程习惯的考虑与设计：<br /><br />
	前面我们多次提到Router.navigate方法连续调用问题，view的postMessageTo问题等，这些前面也做了一些讨论，并且有相关的解决方案，接下来我们看下面的这个问题：<br />
	<div style="height:300px;overflow:auto">
		click:{<br />
		　　selectPage:function(e){<br />
		　　　　//..<br />
		　　　　Router.navigate({page:newPage});//更新page参数<br />
		　　　　e.view.renderUI();//手动更新view<br />
		　　}<br />
		},<br />
		render:function(){<br />
		　　var qm=this.getLocation();//<br />
		　　var page=qm.get('page');//立即获取page参数<br />
		}
	</div>
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	我们重点看这2行代码：<br />
	Router.navigate({page:newPage});//更新page参数<br />
	e.view.renderUI();//手动更新view<br />
	根据前面我们讨论的问题可以知道，如果使用hash值来保存当前url状态时，这2行的代码存在问题，就是navigate方法更新hash是异步的，当下面的e.view.renderUI方法被调用时，直接通过getLocation方法或原来的queryModel拿到的page参数并不是刚刚放上去的，因为异步嘛，要解决该问题需要这样写代码：<br />
	Router.navigate({page:newPage});//更新page参数<br />
	Router.idle(function(){//router在更改完毕处于闲置状态时回调<br />
	　　e.view.renderUI();//更新view<br />
	})<br />	
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	把要执行的方法放在回调中确实能够顺利解决问题，但并不是每个开发人员都能够清楚的认识到router.navigate方法在修改hash时是异步的(使用pushState时并无此问题)，因此有解决方案未必就能很好的解决问题，开发人员未必就会去用，像我们原来的在异步的回调中需要判断exist一样，虽然有解决方案，但是很少有人记得去调用，这就是可怕的习惯问题<br /><br />
	magix/view这块经过潜心钻研，目前已能够按开发人员的习惯正确处理这些问题，比如下页的示例：
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	click:{<br />
	　　selectPage:function(e){<br />
	　　　　//..<br />
	　　　　Router.navigate({page:newPage});//更新page参数<br />
	　　　　e.view.renderUI();//手动更新view<br />
	　　}<br />
	},<br />
	render:function(){<br />
	　　var qm=this.getLocation();//<br />
	　　var page=qm.get('page');//立即获取page参数<br />
	}<br />
	现在你这样写是不存在任何问题的，^_^，甚至你可以这样写：
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	click:{<br />
	　　selectPage:function(e){<br />
	　　　　//..<br />
	　　　　Router.navigate({page:newPage});//更新page参数<br />
	　　　　e.view.<span class="red">XX</span>();//随便调用一个方法<br />
	　　}<br />
	},<br />
	<span class="red">XX</span>:function(){//在这个方法内立即获取刚放上去的参数<br />
	　　var qm=this.getLocation();//<br />
	　　var page=qm.get('page');//立即获取page参数<br />
	}<br />
	方法名称可以是任意的哦
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	当然除了这个之外，像前面提到的异步更新html问题，自动对render,renderUI,updateUI这3个方法进行异步处理，这些都是为了照顾开发人员的习惯而特殊定制的，同时对这些方法也有相应的降级方案，只所以对一些方法进行特殊处理，也是基于这么多项目中，开发人员的习惯而设定的，比如renderUI方法。<br /><br />
	你可以根据自已的习惯用这些方便的名称，同时为了满足特殊的需求，也有相应的低级API，比如下面的情况你就需要自行处理：
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	click:{<br />
	　　selectPage:function(e){<br />
	　　　　//..<br />
	　　　　Router.navigate({page:newPage});//更新page参数<br />
	　　　　var params=e.view.XX();//该方法有返回值<br />
	　　}<br />
	},<br />
	XX:function(){//<br />
	　　var qm=this.getLocation();//<br />
	　　var page=qm.get('page');//立即获取page参数，将获取不到<br />
	　　//...<br />
	　　return params;<br />
	}<br />
	对于有返回值的方法暂时是不行的，您需要改成这样：
</div>

<!--page-->
<div class="title">
	目录-代码细节与风险-View
</div>
<div class="content text">
	click:{<br />
	　　selectPage:function(e){<br />
	　　　　//..<br />
	　　　　Router.navigate({page:newPage});//更新page参数<br />
	　　　　<span class="red">e.view.idle(function(){</span>//您可以认为view.idle是router.idle的快捷方式<br />
	　　　　　　var params=e.view.XX();//该方法有返回值<br />
	　　　　<span class="red">});</span><br />
	　　}<br />
	},<br />
	XX:function(){//<br />
	　　var qm=this.getLocation();//<br />
	　　var page=qm.get('page');//立即获取page参数，将获取不到<br />
	　　//...<br />
	　　return params;<br />
	}
</div>

<!--page-->
<div class="title">
	
</div>
<div class="content" style="text-align:center;font-size:1000%">
	Thanks
</div>